Продолжим разбирать концепции JavaScript'а и сегодня быстро посмотрим на то, как использовать все преимущества блочной зоны видимости без `let` и `const`, только с помощью `var` и небольшой хитрости. 

В прошлом посте я уже рассказал о том что такое блочная область видимости, но иногда речь заходит о поддержке старых версий EcmaScript, поддержке старых браузеров ( что сейчас уже пусть и актуально, но не так сильно, как раньше ). В таких случаях мы не можем использовать let и const, а следовательно и блочная область видимости нам недоступна. В таких случаях используют IIFE.

IIFE — Immediately-invoked Function Expression — или мгновенно вызываемое функциональное выражение. Это определенный синтаксический прием, который позволяет сразу объявить и вызвать функцию в указанном месте. Таким образом мы создаем костыльный аналог блочной области видимости, который ограничено областью видимости этого функционального выражения. Тут рассмотрим пример.

Допустим, нам нужно проитерироваться по массиву и вывести его значения через какой-то промежуток времени:
```
var array = [1, 2, 3, 4, 5]

for (var i = 0; i < array.length; i++) {
  setTimeout(() => {
    console.log(array[i])
  }, 500)
}
```

Казалось бы, все предельно просто и мы ожидаем вывод чисел от 1 до 5 последовательно через 500 миллисекунд. Но вот нет, всё не так просто. Какой бы вывод вы не ожидали, очень много людей тут делают ошибки. 
На самом деле вывод такой: 
```
undefined
undefined
undefined
undefined
undefined
```
Что? Почему? Всё из-за особенностей объявления переменной через var. Итерация проходит менее чем за 500мс. На моём ПК она проходит всего за 2мс. Значение переменной `i` в начале последнего прохода достигает значения 4, а в конце прохода становится равной 5 ( т.к. выражение `i++` выполняется после отрабатывания всего тела `for` )

Функция `setTimeout` никак не блокирует поток, поэтому мы быстро итерируемся, получаем `i = 5`, а через еще 498мс обращаемся к `array[5]`, но такого элемента нет, максимум 4, нумерация же с нуля. При этом с `let` всё работает отлично

И когда нужно получить ожидаемый вывод, но нельзя использовать новый синтаксис, используется IIFE. Выглядят они так:
```
(function(локальное название переменных) {
  тело функции
})(переменные на вход)
```

Перепишем вышеописанный пример с использованием IIFE:
```
for (var i = 0; i < array.length; i++) {
  (function(i) {
    setTimeout(() => {
      console.log(array[i])
    }, 500)
  })(i)
}
```

Создаем функцию как блок, закидываем туда какие-то операции, оборачиваем в скобочки и сразу же вызываем с нужными параметрами. Таким образом создаем новую функциональную область видимости, которая нам и нужна.

В итоге получаем ожидаемый вывод: 
```
1
2
3
4
5
```

Супер простой концепт, но много проблем решает. Вот мы и реализовали задачу в старом синтаксисе, ничего сложного. 

И на этом всё, спасибо за прочтение. Если вам не лень, то поделитесь каналом с друзьями. Аудитория лишней точно не бывает. Люблю.